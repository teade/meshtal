//! Handles various conversions to Visual Toolkit file formats
//!
//! This module is used as a coupling layer between internal types and the vtkio
//! crate for writing.
//!
//! # Overview
//!
//! The intended workflow is to:
//!
//! 1. Configure the appropriate convertor
//! 2. Convert into a `vtkio` VTK
//! 3. Write to file in the required format with [write_vtk()]
//!
//! Often the default configuration will suffice. The convenience functions
//! [mesh_to_vtk()] and [weights_to_vtk()] will quickly convert to a VTK ready
//! for writing with [write_vtk()].
//!
//! ```rust
//! # use meshtal::vtk::{mesh_to_vtk, write_vtk};
//! # use meshtal::mesh::{Mesh};
//! // Get a mesh
//! let mesh = Mesh::default();
//!
//! // Convert to VTK with the default configuration
//! let vtk = mesh_to_vtk(&mesh);
//!
//! // Wite the VTK to a file in one of several formats
//! // write_vtk(vtk, "output.vtk", VtkFormat::Xml).unwrap();
//! ```
//!
//! For more comprehensive examples, see the relevant struct documentation and
//! the next section.
//!
//! # Conversion
//!
//! The fields of [MeshToVtk] and [WeightsToVtk] are left public for direct use.
//! However, builder patterns are also implemented. This helps separate the
//! configuration from the conversion logic, and is often a style preference for
//! users. The following examples are therefore equivalent.
//!
//! The builder approach:
//!
//! ```rust
//! # use meshtal::vtk::{MeshToVtk, MeshToVtkBuilder};
//! # use meshtal::mesh::{Mesh, Group};
//! # let mesh = Mesh::default();
//! // Make a new builder, change some values
//! let mesh_convertor = MeshToVtk::builder()
//!     .include_errors(true)
//!     .energy_groups(vec![Group::Total])
//!     .resolution(3)
//!     .build();
//!
//! // Convert the mesh using the parameters set
//! let vtk = mesh_convertor.convert(&mesh);
//! ```
//!
//! The direct approach:
//!
//! ```rust
//! # use meshtal::vtk::{MeshToVtk, MeshToVtkBuilder};
//! # use meshtal::mesh::{Mesh, Group};
//! # let mesh = Mesh::default();
//! // Make a new instance, change some values
//! let mut mesh_convertor = MeshToVtk::new();
//! mesh_convertor.include_errors = true;
//! mesh_convertor.energy_groups = vec![Group::Total];
//! mesh_convertor.resolution = 3;
//!
//! // Convert the mesh using the parameters set
//! let vtk = mesh_convertor.convert(&mesh);
//! ```
//!
//! In the background, a call to [MeshToVtk::new()] or [WeightsToVtk::new()]
//! simply returns a default configuration generated by the builders anyway.

// standard library
use std::ops::RangeInclusive;
use std::path::Path;

// internal modules
use crate::mesh::{Geometry, Group, Mesh};
use crate::utils::*;
use crate::weights::WeightWindow;

// extrenal crates
use anyhow::{anyhow, Ok, Result};
use clap::ValueEnum;
use log::{debug, trace, warn};
use vtkio::model::*;
use vtkio::xml::Compressor;

/// Write any vtk to file
///
/// Takes any VTK and calls the appropriate vtkio writer depending on the
/// desired format.
///
/// The file format is set using variants of the [VtkFormat] enum. The
/// compression and endian options are set as part of the VTK, typically done
/// in the conversion phase.   
///
/// ```rust
/// # use meshtal::vtk::{mesh_to_vtk, write_vtk};
/// # use meshtal::mesh::{Mesh};
/// // Get a mesh
/// let mesh = Mesh::default();
///
/// // Convert to VTK with the default configuration
/// let vtk = mesh_to_vtk(&mesh);
///
/// // Wite the VTK to a file in one of several formats
/// // write_vtk(vtk, "output.vtk", VtkFormat::Xml).unwrap();
/// ```
///
/// Note that if this is called manually the path extension must be correct or
/// vtkio will get thow and error. For XML, the file must end in `.vtr` for
/// rectangular meshes (rectilinear grid), and `.vtu` for cylindrical meshes
/// (unstructured). For all both legacy formats `.vtk` will work fine.
pub fn write_vtk(vtk: Vtk, path: impl AsRef<Path>, format: VtkFormat) -> Result<()> {
    match format {
        VtkFormat::Xml => vtk.export(path),
        VtkFormat::LegacyBinary => match vtk.byte_order {
            ByteOrder::BigEndian => vtk.export_be(path),
            ByteOrder::LittleEndian => vtk.export_le(path),
        },
        VtkFormat::LegacyAscii => vtk.export_ascii(path),
    }
    .map_err(|e| anyhow!("Unable to write VTK to file: {e}"))
}

/// Convert a mesh tally to vtk using default options
///
/// Suitable for very quick conversions, but for control over conversion options
/// use [MeshToVtk] and the [MeshToVtkBuilder] to change the configuration.
///
/// ```rust
/// # use meshtal::vtk::{mesh_to_vtk, write_vtk};
/// # use meshtal::mesh::{Mesh};
/// // Get a mesh
/// let mesh = Mesh::default();
///
/// // Convert to VTK with the default configuration
/// let vtk = mesh_to_vtk(&mesh);
///
/// // Wite the VTK to a file in one of several formats
/// // write_vtk(vtk, "output.vtk", VtkFormat::Xml).unwrap();
/// ```
pub fn mesh_to_vtk(mesh: &Mesh) -> Result<Vtk> {
    MeshToVtkBuilder::default().build().convert(mesh)
}

/// Convert a set of weights to vtk using default options
///
/// Not yet implemented
pub fn weights_to_vtk() -> Result<Vtk> {
    todo!()
}

// !    ----------------------
// !    Convenience structures
// !    ----------------------

/// Vertex for use in cylindrical and unstructured mesh types
struct Vertex {
    x: f64,
    y: f64,
    z: f64,
}

impl Vertex {
    /// turn vertex into a vector, rounding to 5 decimal places for consistency
    fn as_array(&self) -> [f64; 3] {
        [Self::rnd(self.x), Self::rnd(self.y), Self::rnd(self.z)]
    }

    /// Pass aling simple translations by (x,y,z) cartesian coordinates
    fn translate(mut self, origin: &[f64; 3]) -> Vertex {
        self.x += origin[0];
        self.y += origin[1];
        self.z += origin[2];
        self
    }

    /// Force rounding of f64 to 5 decimal places
    ///
    /// Makes absolutely sure the vertex points are not slightly off due to f64
    /// rounding errors. The points in meshtal files are are only to 5 decimal
    /// places anyway so this should not lose precision.
    fn rnd(value: f64) -> f64 {
        let factor: f64 = (10_f64).powf(5.0);
        (factor * value).round() / factor
    }
}

/// Enum of VTK output formats
///
/// [VtkFormat::Xml] is recommended as the most modern format that also supports
/// compression to reduce file sizes.
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
pub enum VtkFormat {
    /// Extensible Markup Language (xml)
    Xml,
    /// ASCII text file
    LegacyAscii,
    /// ASCII headers with binary data
    LegacyBinary,
}

// !    -----------------
// !    Mesh tally to VTK
// !    -----------------

/// Convert mesh tallies to vtk formats for plotting
///
/// All of the of logic for converting voxel data into the right VTK types and
/// formats is implemented here. This includes calculating verticies for
/// cylindrical cases as an unstructured mesh.
///
/// # Configuring the conversion
///
/// The fields remain public for direct use, but for convenience and style
/// preference a builder pattern is also implemented. The following are
/// therefore equivalent:
///
/// The builder approach:
///
/// ```rust
/// # use meshtal::vtk::{MeshToVtk, MeshToVtkBuilder};
/// # use meshtal::mesh::{Mesh, Group};
/// # let mesh = Mesh::default();
/// // Make a new builder, change some values, and convert the mesh
/// let mesh_convertor = MeshToVtk::builder()
///     .include_errors(true)
///     .energy_groups(vec![Group::Total])
///     .resolution(3)
///     .build();
///
/// // Convert to VTK with the default configuration
/// let vtk = mesh_convertor.convert(&mesh);
/// ```
///
/// The direct approach:
///
/// ```rust
/// # use meshtal::vtk::{MeshToVtk, MeshToVtkBuilder};
/// # use meshtal::mesh::{Mesh, Group};
/// # let mesh = Mesh::default();
/// // Make a new instance, change some values, and convert the mesh
/// let mut mesh_convertor = MeshToVtk::new();
/// mesh_convertor.include_errors = true;
/// mesh_convertor.energy_groups = vec![Group::Total];
/// mesh_convertor.resolution = 3;
///
/// // Convert to VTK with the default configuration
/// let vtk = mesh_convertor.convert(&mesh);
/// ```
///
/// # General properties
///
/// ## Targeting specific voxel groups
///
/// **Important: By default all energy groups are included in the vtk**.
///
/// Specific energy groups can be provided to reduce file sizes. This is also
/// especially useful if only certain groups are of interest.
///
/// For example, often only the `Total` groups are wanted:
///
/// ```rust
/// # use meshtal::vtk::{MeshToVtk};
/// # use meshtal::mesh::{Group};
/// // Choose only the 'Total' of each energy group
/// let mesh_convertor = MeshToVtk::builder()
///     .energy_groups(vec![Group::Total])
///     .time_groups(vec![Group::Total])
///     .build();
/// ```
///
/// For specific energy/time groups:
///
/// ```rust
/// # use meshtal::vtk::{MeshToVtk};
/// # use meshtal::mesh::{Group};
/// // Choose specific energy and time groups
/// let mesh_convertor = MeshToVtk::builder()
///     .energy_groups(vec![Group::Value(1.0),
///                         Group::Value(20.0),
///                         Group::Total])
///     .build();
/// ```
///
/// ## Error meshes
///
/// Error meshes omitted by default to save space. If enabled, every mesh
/// will have a corresponding relative uncertainty dataset. Of course, this
/// ~doubles file size, which is fine in most cases.
///
/// ```rust
/// # use meshtal::vtk::{MeshToVtk};
/// // Include error meshes for each result
/// let mesh_convertor = MeshToVtk::builder()
///     .include_errors(true)
///     .build();
/// ```
///
/// ## Vtk formatting
///
/// Included are a couple of more advanced options for VTK preferences.
///
/// Most useful is the byte ordering, which is important for binary file
/// compatability with plotting software. ParaView does not care, but something
/// like Visit only likes big endian. This is the default for convenience but is
/// completely up to the user.
///
/// ```rust
/// # use meshtal::vtk::{MeshToVtk};
/// # use vtkio::model::ByteOrder;
/// // Change the byte ordering to little endian
/// let mesh_convertor = MeshToVtk::builder()
///     .byte_order(ByteOrder::LittleEndian)
///     .build();
/// ```
///
/// Perhaps less useful is the compression method for XML file formats, but it
/// is included for completeness anyway.
///
/// ```rust
/// # use meshtal::vtk::{MeshToVtk};
/// # use vtkio::xml::Compressor;
/// // Select the LZMA compression method
/// let mesh_convertor = MeshToVtk::builder()
///     .compressor(Compressor::LZMA)
///     .build();
/// ```
///
/// Generally just use LZMA but other options are available:
/// - lzma (default)
/// - lz4
/// - zlib
/// - none
///
/// # A note on Cylindrical meshes
///
/// There is no VTK representation of cylindrical meshes, so an unstructured
/// mesh is generated from verticies based on the RZT bounds.
///
/// Unfortunately, this can result in "low-resolution" plots for meshes with
/// few theta bins. The number of theta bins can be increased to round off these
/// edges. This simply subdivides the voxels by an integer number of theta bins.
///
/// ![Cylindrical mesh resolution option](https://github.com/repositony/meshtal/blob/main/data/assets/cylindrical_mesh_resolution.png)
///
/// For example:
///
/// ```rust
/// # use meshtal::vtk::{MeshToVtk};
/// // Split every theta bin into 3 to round off the edges
/// let mesh_convertor = MeshToVtk::builder()
///     .resolution(3)
///     .build();
/// ```
///
/// Setting the `resolution` to 3 will subbdivide the theta bins into 3, thereby
/// tripling the number of edges plotted from 8 to 24 for a more rounded look.
///
/// Note that this can increase memory usage and file size significantly but is
/// a nice feature for generating more accurate cylinders.  
///
#[derive(Debug, PartialEq)]
pub struct MeshToVtk {
    /// Target energy group(s)
    pub energy_groups: Vec<Group>,
    /// Target energy group(s)
    pub time_groups: Vec<Group>,
    /// Include errors mesh in output files
    pub include_errors: bool,
    /// Byte ordering as big or little endian
    pub byte_order: ByteOrder,
    /// compression method for xml file formats
    pub compressor: Compressor,
    /// Cylindrical mesh resolution
    pub resolution: u8,
}

// Public API
impl MeshToVtk {
    /// Start with the default configuration
    pub fn new() -> MeshToVtk {
        Default::default()
    }

    /// Get an instance of the [MeshToVtkBuilder]
    pub fn builder() -> MeshToVtkBuilder {
        MeshToVtkBuilder::default()
    }

    /// Convert a [Mesh] to Vtk object
    ///
    /// Once the configuration is set through either the builder or changing the
    /// fields directly, convert any [Mesh] into a Vtk ready for writing or
    /// futher processing.
    pub fn convert(&self, mesh: &Mesh) -> Result<Vtk> {
        match mesh.geometry {
            Geometry::Rectangular => self.rectangular_vtk(mesh),
            Geometry::Cylindrical => self.cylindrical_vtk(mesh),
        }
    }
}

impl Default for MeshToVtk {
    fn default() -> Self {
        MeshToVtkBuilder::default().build()
    }
}

/// Common use implementations
impl MeshToVtk {
    /// Collect energy groups, and if none are given just use the Total
    fn collect_energy_groups(&self, mesh: &Mesh) -> Vec<Group> {
        let groups = mesh.energy_groups();

        // none defined? convert everything
        if self.energy_groups.is_empty() {
            trace!("No energy groups requested, defaulting to all");
            groups
        }
        // otherwise try to find the relevant groups if within the mesh bounds
        else {
            let mut indicies = self
                .energy_groups
                .iter()
                .filter_map(|energy| mesh.find_energy_group_index(*energy).ok())
                .collect::<Vec<usize>>();
            trace!("Found {:?}", indicies);
            indicies.sort();
            indicies.dedup();

            indicies.iter().map(|idx| groups[*idx]).collect()
        }
    }

    /// Collect time groups, and if none are given just use the Total
    fn collect_time_groups(&self, mesh: &Mesh) -> Vec<Group> {
        let groups = mesh.time_groups();
        // none defined? convert everything
        if self.time_groups.is_empty() {
            trace!("No time groups requested, defaulting to all");
            groups
        }
        // otherwise try to find the relevant groups if within the mesh bounds
        else {
            let mut indicies = self
                .time_groups
                .iter()
                .filter_map(|time| mesh.find_time_group_index(*time).ok())
                .collect::<Vec<usize>>();
            indicies.sort();
            indicies.dedup();

            indicies.iter().map(|idx| groups[*idx]).collect()
        }
    }

    /// Create a name to display in the output mesh data
    fn group_name(&self, energy: Group, time: Group) -> String {
        // decide on energy prefix
        let energy_prefix = match energy {
            Group::Value(e) => f!("{e:.2E}MeV_"),
            Group::Total => "total_".to_string(),
        };

        // decide on time prefix, ommit if there is only one
        let time_prefix = match time {
            Group::Value(t) => f!("{t:.2E}shakes_"),
            Group::Total => {
                if self.time_groups.len() > 1 {
                    "total_".to_string()
                } else {
                    "".to_string()
                }
            }
        };

        energy_prefix + &time_prefix
    }
}

/// Implementations for proecessing Rectangular mesh types
impl MeshToVtk {
    /// Convert mesh voxel data to vtkio types for writing
    fn rectangular_vtk(&self, mesh: &Mesh) -> Result<Vtk> {
        debug!("Generating RectilinearGrid from mesh");
        Ok(Vtk {
            version: Version::Auto,
            title: f!("Fmesh{} results", mesh.id),
            byte_order: self.byte_order,
            file_path: None,
            data: DataSet::inline(RectilinearGridPiece {
                extent: Self::extent(mesh),
                coords: Self::coordinates(mesh),
                data: self.collect_attributes(mesh),
            }),
        })
    }

    /// Defines number of mesh voxels in each extent for the rectilinear grid
    fn extent(mesh: &Mesh) -> Extent {
        let range_ext: RangeExtent = [
            RangeInclusive::new(0, mesh.iints as i32),
            RangeInclusive::new(0, mesh.jints as i32),
            RangeInclusive::new(0, mesh.kints as i32),
        ];
        Extent::Ranges(range_ext)
    }

    /// Defines coordiantes for rectilinear grid from mesh bounds
    fn coordinates(mesh: &Mesh) -> Coordinates {
        Coordinates {
            x: IOBuffer::F64(mesh.imesh.clone()),
            y: IOBuffer::F64(mesh.jmesh.clone()),
            z: IOBuffer::F64(mesh.kmesh.clone()),
        }
    }

    /// Collect rectilinear cell results into appropriate order/format
    fn collect_attributes(&self, mesh: &Mesh) -> Attributes {
        trace!("Collecting attributes");
        let mut attributes: Attributes = Attributes::new();

        let energy_groups = self.collect_energy_groups(mesh);
        let time_groups = self.collect_time_groups(mesh);

        for e in &energy_groups {
            trace!("Cell data for E = {e} MeV");
            for t in &time_groups {
                trace!("  |__ T = {t} shakes");

                // todo unnecessary allocation
                let voxels = mesh.slice_voxels_by_group(*e, *t).unwrap();

                let (results, errors): (Vec<f64>, Vec<f64>) = voxels
                    .iter()
                    .map(|v| (v.result, v.error))
                    .collect::<Vec<(f64, f64)>>()
                    .into_iter()
                    .unzip();

                let cell_data = DataArray {
                    name: self.group_name(*e, *t) + "result",
                    elem: ElementType::Scalars {
                        num_comp: 1,
                        lookup_table: None,
                    },
                    data: IOBuffer::F64(Self::sort_by_cell_index(mesh, results)),
                };
                attributes.cell.push(Attribute::DataArray(cell_data));

                // do the same for the errors if they are to be included
                if self.include_errors {
                    let cell_data = DataArray {
                        name: self.group_name(*e, *t) + "error",
                        elem: ElementType::Scalars {
                            num_comp: 1,
                            lookup_table: None,
                        },
                        data: IOBuffer::F64(Self::sort_by_cell_index(mesh, errors)),
                    };
                    attributes.cell.push(Attribute::DataArray(cell_data));
                }
            }
        }

        attributes
    }

    /// Sort a list of results for the rectilinear grid cell ordering
    fn sort_by_cell_index(mesh: &Mesh, values: Vec<f64>) -> Vec<f64> {
        let idx = (0..values.len())
            .map(|i| mesh.voxel_index_to_cell_index(i))
            .collect::<Vec<usize>>();

        let mut result = idx.iter().zip(values.iter()).collect::<Vec<_>>();

        result.sort_by(|a, b| a.0.cmp(b.0));
        result.into_iter().map(|r| *r.1).collect()
    }
}

/// Implementations for proecessing Cylindrical mesh types
impl MeshToVtk {
    /// Convert mesh voxel data to vtkio types for writing
    fn cylindrical_vtk(&self, mesh: &Mesh) -> Result<Vtk> {
        debug!("Generating UnstructuredGrid from mesh");

        // generate cell verticies from mesh bounds
        let (points, offset, cell_types) = self.cell_verticies(mesh);
        let connect = (0..*offset.last().unwrap()).collect::<Vec<u64>>();

        Ok(Vtk {
            version: Version::Auto,
            title: f!("Fmesh{} results", mesh.id),
            byte_order: self.byte_order,
            file_path: None,
            data: DataSet::inline(UnstructuredGridPiece {
                points: points.into(),
                cells: Cells {
                    cell_verts: VertexNumbers::XML {
                        connectivity: connect,
                        offsets: offset,
                    },
                    types: cell_types,
                },
                data: self.collect_cyl_attributes(mesh),
            }),
        })
    }

    /// Cylinders need to be built explicitly from vertex points
    fn cell_verticies(&self, mesh: &Mesh) -> (Vec<f64>, Vec<u64>, Vec<CellType>) {
        let mut points: Vec<f64> = Vec::new();
        let mut offsets: Vec<u64> = Vec::new();
        let mut cell_types: Vec<CellType> = Vec::new();

        // go layer-by-layer up from z
        for layer in 0..mesh.jints {
            // first inner segments always CellType::Wedge
            self.wedge_segments(mesh, layer, &mut points, &mut offsets, &mut cell_types);

            // any additional ring segments use CellType::Voxel
            if mesh.iints > 1 {
                // start from 1, the first ring is already made from wedges
                for ring in 1..mesh.iints {
                    self.voxel_segments(
                        mesh,
                        ring,
                        layer,
                        &mut points,
                        &mut offsets,
                        &mut cell_types,
                    );
                }
            }
        }

        (points, offsets, cell_types)
    }

    /// For the central voxels where r=0
    fn wedge_segments(
        &self,
        mesh: &Mesh,
        z_idx: usize,
        points: &mut Vec<f64>,
        offsets: &mut Vec<u64>,
        cell_types: &mut Vec<CellType>,
    ) {
        let mut step = 2.0 * std::f64::consts::PI / (mesh.kints as f64);
        step /= self.get_resolution(&mesh.kints) as f64;
        let r = mesh.imesh[1];

        // wedge type has 6 verticies
        // only need to find three and then repeat for the lower layer
        for i in 0..(mesh.kints * self.get_resolution(&mesh.kints) as usize) {
            let t0 = step * (i as f64);
            let t1 = step * (i as f64 + 1.0);

            let x0 = r * t0.cos();
            let y0 = r * t0.sin();

            let x1 = r * t1.cos();
            let y1 = r * t1.sin();

            for idx in z_idx..=(z_idx + 1) {
                let z = mesh.jmesh[idx];
                points.extend(
                    Vertex { x: 0.0, y: 0.0, z }
                        .translate(&mesh.origin)
                        .as_array(),
                );
                points.extend(
                    Vertex { x: x0, y: y0, z }
                        .translate(&mesh.origin)
                        .as_array(),
                );
                points.extend(
                    Vertex { x: x1, y: y1, z }
                        .translate(&mesh.origin)
                        .as_array(),
                );
            }

            Self::update_offsets(offsets, 6);
            cell_types.push(CellType::Wedge);
        }
    }

    /// For anything beyond the first inside ring
    fn voxel_segments(
        &self,
        mesh: &Mesh,
        r_idx: usize,
        z_idx: usize,
        points: &mut Vec<f64>,
        offsets: &mut Vec<u64>,
        cell_types: &mut Vec<CellType>,
    ) {
        let mut step = 2.0 * std::f64::consts::PI / (mesh.kints as f64);
        step /= self.get_resolution(&mesh.kints) as f64;
        let r0 = mesh.imesh[r_idx];
        let r1 = mesh.imesh[r_idx + 1];

        // voxel type has 8 verticies
        // only need to find 4 and then repeat at lower layer
        for i in 0..(mesh.kints * self.get_resolution(&mesh.kints) as usize) {
            let t0 = step * (i as f64);
            let t1 = step * (i as f64 + 1.0);

            let x00: f64 = r0 * t0.cos();
            let y00: f64 = r0 * t0.sin();

            let x01: f64 = r0 * t1.cos();
            let y01: f64 = r0 * t1.sin();

            let x10: f64 = r1 * t0.cos();
            let y10: f64 = r1 * t0.sin();

            let x11: f64 = r1 * t1.cos();
            let y11: f64 = r1 * t1.sin();

            for idx in z_idx..=(z_idx + 1) {
                let z = mesh.jmesh[idx];
                points.extend(
                    Vertex { x: x00, y: y00, z }
                        .translate(&mesh.origin)
                        .as_array(),
                );
                points.extend(
                    Vertex { x: x01, y: y01, z }
                        .translate(&mesh.origin)
                        .as_array(),
                );
                points.extend(
                    Vertex { x: x10, y: y10, z }
                        .translate(&mesh.origin)
                        .as_array(),
                );
                points.extend(
                    Vertex { x: x11, y: y11, z }
                        .translate(&mesh.origin)
                        .as_array(),
                );
            }

            Self::update_offsets(offsets, 8);
            cell_types.push(CellType::Voxel);
        }
    }

    /// Bring all of the cell data together
    fn collect_cyl_attributes(&self, mesh: &Mesh) -> Attributes {
        trace!("Collecting cylindrical attributes");
        let mut attributes: Attributes = Attributes::new();

        let energy_groups = self.collect_energy_groups(mesh);
        let time_groups = self.collect_time_groups(mesh);

        for e in &energy_groups {
            trace!("Cell data for E = {e} MeV");
            for t in &time_groups {
                trace!("  |__ T = {t} shakes");

                let voxels = mesh.slice_voxels_by_group(*e, *t).unwrap().to_vec();

                let (mut results, mut errors): (Vec<f64>, Vec<f64>) = voxels
                    .into_iter()
                    .map(|v| (v.result, v.error))
                    .collect::<Vec<(f64, f64)>>()
                    .into_iter()
                    .unzip();

                results = Self::repeat_values(results, self.get_resolution(&mesh.kints));
                errors = Self::repeat_values(errors, self.get_resolution(&mesh.kints));

                let cell_data = DataArray {
                    name: self.group_name(*e, *t) + "result",
                    elem: ElementType::Scalars {
                        num_comp: 1,
                        lookup_table: None,
                    },
                    data: IOBuffer::F64(results),
                };
                attributes.cell.push(Attribute::DataArray(cell_data));

                // do the same for the errors if they are to be included
                if self.include_errors {
                    let cell_data = DataArray {
                        name: self.group_name(*e, *t) + "error",
                        elem: ElementType::Scalars {
                            num_comp: 1,
                            lookup_table: None,
                        },
                        data: IOBuffer::F64(errors),
                    };
                    attributes.cell.push(Attribute::DataArray(cell_data));
                }
            }
        }

        attributes
    }

    /// Repeat whatever set of values is in a vector
    fn repeat_values(values: Vec<f64>, repeat: u8) -> Vec<f64> {
        values
            .into_iter()
            .flat_map(|n| std::iter::repeat(n).take(repeat.into()))
            .collect()
    }

    /// Used in calculation of verticies
    fn update_offsets(offsets: &mut Vec<u64>, size: usize) {
        let offset = match offsets.is_empty() {
            true => size.try_into().unwrap(),
            false => (size + (*offsets.last().unwrap() as usize))
                .try_into()
                .unwrap(),
        };
        offsets.push(offset);
    }

    /// Fix the resolution issue in the background for 1-2 theta bins
    ///
    /// For performance the converter would have to be mutable, or the user
    /// would have to know to set the resolution for a couple of special cases.
    /// This is just easier for everyone.
    fn get_resolution(&self, n_bins: &usize) -> u8 {
        match n_bins {
            // only one theta bin, minimim verticies needed will be 3
            1 => self.resolution.max(3),
            // only two theta bins, minimim verticies needed will be 4
            2 => self.resolution.max(2),
            // anything else is fine
            _ => self.resolution,
        }
    }
}

/// Builder implementation for MeshToVtk configuration
///
/// The fields of [MeshToVtk] are left public for direct use but the module also
/// implements a builder.
///
/// For those not familiar, the builder allows for chained setter calls for a
/// functional approach that could be considered more readable. Any number of
/// parameters can be set this way (including none).
///
/// To get the final [MeshToVtk] from the builder, call
/// [build()](MeshToVtkBuilder::build).  
///
/// ```rust
/// # use meshtal::vtk::{MeshToVtk, MeshToVtkBuilder};
/// # use meshtal::mesh::{Mesh, Group};
/// # use vtkio::model::ByteOrder;
/// # use vtkio::xml::Compressor;
/// // Dummy mesh
/// let mesh = Mesh::default();
///
/// // Make a new builder, configure parameters, and convert the mesh
/// let mesh_convertor = MeshToVtk::builder()
///     .energy_groups(vec![Group::Total])
///     .time_groups(vec![Group::Value(1e6), Group::Total])
///     .include_errors(true)
///     .resolution(3)
///     .byte_order(ByteOrder::LittleEndian)
///     .compressor(Compressor::LZMA)
///     .build();
///
/// // Convert to a VTK
/// let vtk = mesh_convertor.convert(&mesh);
///
/// // Write to "output.vtk" using the old ASCII text format
/// // write_vtk(vtk, "./output.vtk", VtkFormat::LegacyAscii)?;
/// ```
///
/// This helps separate the configuration from the actual conversion logic, and
/// is often a style preference for many users.
pub struct MeshToVtkBuilder {
    /// Target energy group(s)
    energy_groups: Vec<Group>,
    /// Target energy group(s)
    time_groups: Vec<Group>,
    /// Include errors mesh in output files
    include_errors: bool,
    /// Byte ordering as big or little endian
    byte_order: ByteOrder,
    /// compression method for xml file formats
    compressor: Compressor,
    /// Cylindrical mesh resolution
    resolution: u8,
}

impl MeshToVtkBuilder {
    /// Create a new instance of the builder with default parameters
    pub fn new() -> Self {
        Self::default()
    }

    /// Build the [MeshToVtk] type
    pub fn build(self) -> MeshToVtk {
        MeshToVtk {
            byte_order: self.byte_order,
            compressor: self.compressor,
            resolution: self.resolution,
            energy_groups: self.energy_groups,
            time_groups: self.time_groups,
            include_errors: self.include_errors,
        }
    }

    /// Target energy group(s)
    ///
    /// By default all energy groups are included in the vtk. Specific energy
    /// groups can be provided to reduce file sizes.
    pub fn energy_groups(mut self, groups: Vec<Group>) -> Self {
        debug!("Set energy groups to\n {:?}", groups);
        self.energy_groups = groups;
        self
    }

    /// Target time group(s)
    ///
    /// By default all time groups are included in the vtk. Specific time
    /// groups can be provided to reduce file sizes.
    pub fn time_groups(mut self, groups: Vec<Group>) -> Self {
        debug!("Set time groups to\n {:?}", groups);
        self.time_groups = groups;
        self
    }

    /// Include errors mesh in output files
    ///
    /// Error meshes omitted by default to save space. If enabled, every mesh
    /// will have a corresponding relative uncertainty dataset. Of course, this
    /// ~doubles file size, which is fine in most cases.
    pub fn include_errors(mut self, include: bool) -> Self {
        debug!("Set include errors to {include}");
        self.include_errors = include;
        self
    }

    /// Cylindrical mesh resolution
    ///
    /// Warning: Every vertex is defined explicitly, so large values will
    /// significantly increase memory usage and file size.
    ///
    /// Integer value for increasing angular resolution of cylindrical meshes.
    /// Cylinders are approximated to straight edge segments so it can be useful
    /// to round this off by splitting voxels into multiple smaller segments.
    ///
    /// e.g. 4 theta bins gives 4 edges and therefore looks square. Using
    /// `--resolution 3` generates 12 edges instead and looks more rounded in
    /// plots.
    pub fn resolution(mut self, resolution: u8) -> Self {
        debug!("Set cylinder resolution to {resolution}");
        warn!(
            "Note that increasing cylindrical mesh resolution increases memory usage significantly"
        );
        self.resolution = resolution;
        self
    }

    /// Set the byte ordering
    ///
    /// Note that Visit being Visit only reads big endian, even though most
    /// systems are little endian. The byte order has one variant of the
    /// ByteOrder, defaulting to big endian for convenience.
    pub fn byte_order(mut self, order: ByteOrder) -> Self {
        debug!("Set byte order to {:?}", order);
        self.byte_order = order;
        self
    }

    /// Set the compression method for xml file formats
    ///
    /// Generally just use LZMA but other options are available:
    /// - lzma (default)
    /// - lz4
    /// - zlib
    /// - none
    pub fn compressor(mut self, xml_compressor: Compressor) -> Self {
        debug!("Set xml compressor type to {:?}", xml_compressor);
        self.compressor = xml_compressor;
        self
    }
}

impl Default for MeshToVtkBuilder {
    fn default() -> Self {
        Self {
            byte_order: ByteOrder::BigEndian,
            compressor: Compressor::LZMA,
            resolution: 1,
            energy_groups: Vec::new(),
            time_groups: Vec::new(),
            include_errors: false,
        }
    }
}

// !    --------------------
// !    Weight window to VTK
// !    --------------------

/// Convert weight window sets to vtk formats for plotting
#[derive(Debug, PartialEq)]
pub struct WeightsToVtk {
    /// Byte ordering as big or little endian
    pub byte_order: ByteOrder,
    /// compression method for xml file formats
    pub compressor: Compressor,
    /// Cylindrical mesh resolution
    pub resolution: u8,
}

// Public API
impl WeightsToVtk {
    /// Start with the default configuration
    pub fn new() -> WeightsToVtk {
        Default::default()
    }

    /// Get an instance of the [WeightsToVtkBuilder]
    pub fn builder() -> WeightsToVtkBuilder {
        WeightsToVtkBuilder::default()
    }

    /// Convert a [WeightWindow] to Vtk object
    ///
    /// Once the configuration is set through either the builder or changing the
    /// fields directly, convert any [WeightWindow] into a Vtk ready for writing
    /// or futher processing.
    pub fn convert(&self, weight_window: &WeightWindow) -> Result<Vtk> {
        match weight_window.nwg {
            Geometry::Rectangular => self.rectangular_vtk(weight_window),
            Geometry::Cylindrical => todo!(),
        }
    }
}

impl Default for WeightsToVtk {
    fn default() -> Self {
        WeightsToVtkBuilder::default().build()
    }
}

/// Implementations for proecessing Rectangular mesh types
impl WeightsToVtk {
    /// Convert WeightWindow data to vtkio types for writing
    fn rectangular_vtk(&self, weight_window: &WeightWindow) -> Result<Vtk> {
        debug!("Generating RectilinearGrid from weights");
        Ok(Vtk {
            version: Version::Auto,
            title: f!("{:?} weight window sets", weight_window.particle),
            byte_order: self.byte_order,
            file_path: None,
            data: DataSet::inline(RectilinearGridPiece {
                extent: Self::extent(weight_window),
                coords: Self::coordinates(weight_window),
                data: self.collect_attributes(weight_window),
            }),
        })
    }

    /// Defines number of mesh voxels in each extent for the rectilinear grid
    fn extent(ww: &WeightWindow) -> Extent {
        let range_ext: RangeExtent = [
            RangeInclusive::new(0, ww.nfx as i32),
            RangeInclusive::new(0, ww.nfy as i32),
            RangeInclusive::new(0, ww.nfz as i32),
        ];
        Extent::Ranges(range_ext)
    }

    /// Defines coordiantes for rectilinear grid from mesh bounds
    fn coordinates(ww: &WeightWindow) -> Coordinates {
        Coordinates {
            x: IOBuffer::F64(
                std::iter::once(ww.x0)
                    .chain(ww.qps_x.iter().map(|x| x[1]))
                    .collect(),
            ),
            y: IOBuffer::F64(
                std::iter::once(ww.y0)
                    .chain(ww.qps_y.iter().map(|y| y[1]))
                    .collect(),
            ),
            z: IOBuffer::F64(
                std::iter::once(ww.z0)
                    .chain(ww.qps_z.iter().map(|z| z[1]))
                    .collect(),
            ),
        }
    }

    /// Collect rectilinear cell results into appropriate order/format
    fn collect_attributes(&self, ww: &WeightWindow) -> Attributes {
        trace!("Collecting attributes");
        let mut attributes: Attributes = Attributes::new();

        // already ordered correctly so can just iterate over each set
        let weight_sets = ww.weights.chunks(ww.nfx * ww.nfy * ww.nfz);

        for (i, group) in weight_sets.enumerate() {
            let cell_data = DataArray {
                // todo: do something more clever here later
                name: f!("group_{i}"),
                elem: ElementType::Scalars {
                    num_comp: 1,
                    lookup_table: None,
                },
                data: IOBuffer::F64(group.to_vec()),
            };
            attributes.cell.push(Attribute::DataArray(cell_data));
        }

        attributes
    }
}

/// Builder implementation for WeightsToVtk configuration
pub struct WeightsToVtkBuilder {
    /// Byte ordering as big or little endian
    byte_order: ByteOrder,
    /// compression method for xml file formats
    compressor: Compressor,
    /// Cylindrical mesh resolution
    resolution: u8,
}

impl WeightsToVtkBuilder {
    /// Create a new instance of the builder with default parameters
    pub fn new() -> Self {
        Self::default()
    }

    /// Build the [WeightsToVtk] type
    pub fn build(self) -> WeightsToVtk {
        WeightsToVtk {
            byte_order: self.byte_order,
            compressor: self.compressor,
            resolution: self.resolution,
        }
    }

    /// Cylindrical mesh resolution
    ///
    /// Warning: Every vertex is defined explicitly, so large values will
    /// significantly increase memory usage and file size.
    ///
    /// Integer value for increasing angular resolution of cylindrical meshes.
    /// Cylinders are approximated to straight edge segments so it can be useful
    /// to round this off by splitting voxels into multiple smaller segments.
    ///
    /// e.g. 4 theta bins gives 4 edges and therefore looks square. Using
    /// `--resolution 3` generates 12 edges instead and looks more rounded in
    /// plots.
    pub fn resolution(mut self, resolution: u8) -> Self {
        debug!("Set cylinder resolution to {resolution}");
        warn!(
            "Note that increasing cylindrical mesh resolution increases memory usage significantly"
        );
        self.resolution = resolution;
        self
    }

    /// Set the byte ordering
    ///
    /// Note that Visit being Visit only reads big endian, even though most
    /// systems are little endian. The byte order has one variant of the
    /// ByteOrder, defaulting to big endian for convenience.
    pub fn byte_order(mut self, order: ByteOrder) -> Self {
        debug!("Set byte order to {:?}", order);
        self.byte_order = order;
        self
    }

    /// Set the compression method for xml file formats
    ///
    /// Generally just use LZMA but other options are available:
    /// - lzma (default)
    /// - lz4
    /// - zlib
    /// - none
    pub fn compressor(mut self, xml_compressor: Compressor) -> Self {
        debug!("Set xml compressor type to {:?}", xml_compressor);
        self.compressor = xml_compressor;
        self
    }
}

impl Default for WeightsToVtkBuilder {
    fn default() -> Self {
        Self {
            byte_order: ByteOrder::BigEndian,
            compressor: Compressor::LZMA,
            resolution: 1,
        }
    }
}
